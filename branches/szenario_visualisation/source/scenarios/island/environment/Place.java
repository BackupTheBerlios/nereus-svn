/* Generated by Together */

package scenario.islandenviroments;

import java.util.Hashtable;
import java.util.Vector;

import utils.Id;
import weka.core.Attribute;
import weka.core.Instance;
import exceptions.InvalidAgentException;
import exceptions.InvalidElementException;

/**
 * Die Klasse stellt einen Platz in der Insel-Umwelt des Insel-Szenarios dar. 
 * Innerhalb des Graphen den die Insel darstellt entspricht der Platz einem 
 * Knoten. 
 * 
 * @author Daniel Friedrich
 */
public class Place {
	
	/**
	 * Eindeutiger Identifier des Platzes
	 */
	private Id m_id;
	
	/**
	 * Attributbeschreibung
	 */
	private Hashtable m_attributes;
	
	/**
	 * Enthält die Attributewerte
	 */
	private Instance m_instance;

    /**
     * Alle Plätze in der Nachbarschaft des Platzes, d.h. alle Plätze die direkt
     * über einen Weg mit dem Platz verbunden sind.  
     */
	private Vector m_neighbourhood;
	
	/**
	 * Flag das angibt ob am Platz schon gegraben wurde
	 */
	private boolean m_isExplored = false;
	
	/**
	 * Id des Agenten der sich aktuell am Ort befindet, nur dieser darf
	 * Informationen über den Platz bekommen.
	 */ 
	private Id m_agent;
	
	/**
	 * Konstruktor.
	 * 
	 * @param values
	 * @param neighbourhood
	 */
	public Place(Instance instance, Hashtable attributes) {
		// create a new Id
		m_id = new Id();
		// // save Instance
		m_instance = instance;
		// save attribute
		m_attributes = attributes;

	}
	
	/**
	 * Setzt die Nachbarschaft des Agenten.
	 * 
	 * Die Methode ist nur zum Aufbau des Graphen gedacht.
	 * 
	 * @param neighbourhood
	 */
	public void setNeighbourhood(Vector neighbourhood) {
		// save neighbourhood
		m_neighbourhood = neighbourhood;		
	}
	
	/**
	 * Liefert die Id des Platzes.
	 * 
	 * @return Id - Id des Platzes
	 */
	public Id getId() {
		return m_id; 
	}
	
	/**
	 * Teilt dem Platz mit, dass der Agent sich nun bei ihm befindet.
	 * 
	 * @param agentId
	 */
	public void setAgent(Id agentId) {
		m_agent = agentId;
	}
	
	/**
	 * Teilt dem Platz mit, das sich der Agent weiter bewegt hat.
	 */
	public void removeAgent() {
		m_agent = null;
	}
	
	/**
	 * Gibt den Wert eines Nominalen Attributes als String zurück.
	 * 
	 * @param agentId
	 * @param name
	 * @return String - Wert des nominalen Attributs
	 * @throws NoSuchInstanceFoundException
	 * @throws InvalidAgentException
	 */
	public String getNominalAttributeValue(Id agentId, String name) 
		throws InvalidElementException, 
				InvalidAgentException {
		if((m_agent != null) && (agentId.equals(m_agent))) {
			if(m_attributes.containsKey(name)) {
				Attribute tmpAttribute = (Attribute)m_attributes.get(name);
				return m_instance.stringValue(tmpAttribute);
			}else {
				throw new InvalidElementException(
					"Instanz für Platz " + m_id.toString());
			}
		}else {
			throw new InvalidAgentException();
		}
	}
	
	/**
	 * Gibt die Werte des Platzes zurück.
	 * 
	 * @param agentId
	 * @return Instance - Attribute des Platzes als Weka-Instanz
	 * @throws InvalidAgentException
	 */
	public Instance getInstance(Id agentId) 
		throws InvalidAgentException {
		if((m_agent != null) && (agentId.equals(m_agent))) {
			return m_instance;
		}else {
			throw new InvalidAgentException();
		}
	}
	
	/**
	 * Liefert die Instance der Attribute des Platzes.
	 *  
	 * @return Instance - Attribute des Platzes als Weka-Instanz 
	 */
	public Instance getInstance() {
		Instance retval = new Instance(m_instance);
		retval.setDataset(m_instance.dataset());
		return retval;
	}
	
	/**
	 * Teilt dem Platz mit das explored wurde.
	 */
	private void setExplored() {
		m_isExplored = true;
	}
	
	/**
	 * Liefert einen Vector mit allen erreichbaren Nachbarn zurück.
	 * 
	 * @return Vector - Alle erreichbaren Nachbarn
	 * @throws InvalidAgentException
	 */
	public Vector getReachablePlaces() {
		return m_neighbourhood;
	}
	
	/**
	 * Gibt an ob am Platz schon gegraben wurde.
	 * @return boolean - True Platz ist ausgebeutet / Falls Platz ist unberührt
	 */
	public boolean isExplored(Id agentId) throws InvalidAgentException {
		if((m_agent != null) && (agentId.equals(m_agent))) {
			return m_isExplored;
		}else {
			throw new InvalidAgentException();	
		}
	}
	
	/**
	 * Führt die Grabung aus und gibt zurück, ob dabei eine Energiezelle gefunden wurde.
	 * 
	 * @param agentId
	 * @return boolean - Gibt zurück ob der Platz eine Energiezelle enthält.
	 * @throws InvalidAgentException
	 */
	public boolean explore(Id agentId) throws InvalidAgentException {
		if((m_agent != null) && (agentId.equals(m_agent))) {
			if(!m_isExplored) {
				this.setExplored();
				return this.containsEnergyCell();
			}else {
				return false;
			}
		}else {
			throw new InvalidAgentException();	
		}
	}
	
	/**
	 * Gibt an ob der Platz leer, d.h. von noch keinem Agenten besetzt ist.
	 * 
	 * @return boolean - True Platz ist leer / False - Platz ist besetzt
	 */
	public boolean isEmpty() {
		if(m_agent == null) {
			return true;
		}
		return false;
	}
	
	/**
	 * Liefert die Id des Agenten der sich gerade am Platz befindet oder null.
	 * 
	 * @return Id oder null - Id des Agenten der sich am Platz befindet.
	 */
	public Id getAgentId() {
		return m_agent;
	}

	/**
	 * Gibt zurück ob sich an dem Ort eine Energiezelle befindet.
	 * 
	 * Liefert auf dann noch true, wenn die Energiezelle bereits ausgegraben
	 * wurde.
	 * 
	 * @return boolean - True es befindet sich eine E-Zelle dort.
	 */
	public boolean containsEnergyCell() {
		double classValue = m_instance.classValue();
		if(classValue > ((double)0.1)) {
			return true;
		}			
		return false;
	}
	
	/**
	 * Gibt zurück ob der Platz erforscht worden ist.
	 * 
	 * Bitte nur zum statistischen Gebrauch verwenden.
	 * 
	 * @return boolean - True Platz ist ausgebeutet / False nicht ausgebeutet.
	 */
	public boolean isExplored() {
		return m_isExplored;
	}
}
